
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>쉐키나 찬양팀 곡 검색</title>
  <style>
    :root{
      --bd:#e5e7eb; --fg:#111827; --muted:#6b7280; --bg:#ffffff;
      --chip:#f3f4f6; --warn:#991b1b; --ok:#065f46;
      --shadow: 0 10px 30px rgba(17,24,39,.08);
    }
    *{ box-sizing:border-box; }
    body{
      margin:0; font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans KR", Arial, sans-serif;
      background:var(--bg); color:var(--fg);
    }
    .wrap{ max-width:1080px; margin:0 auto; padding:22px; }
    h1{ font-size:20px; margin:0 0 6px; letter-spacing:-.2px; }
    .sub{ color:var(--muted); font-size:13px; margin-bottom:14px; line-height:1.55; }
    .muted{ color:var(--muted); font-size:12px; }

    .card{
      border:1px solid var(--bd); border-radius:16px; padding:14px; margin:12px 0;
      box-shadow:var(--shadow); background:#fff;
    }
    label{ font-size:12px; color:var(--muted); display:block; margin-bottom:6px; }
    .searchWrap{ position:relative; }
    input[type="text"]{
      width:100%; padding:12px 44px 12px 12px; border:1px solid var(--bd); border-radius:12px;
      font-size:15px; outline:none; transition:border-color .15s ease, box-shadow .15s ease;
    }
    input[type="text"]:focus{ border-color:#cbd5e1; box-shadow:0 0 0 4px rgba(148,163,184,.25); }
    .clearBtn{
      position:absolute; right:8px; top:50%; transform:translateY(-50%);
      border:1px solid var(--bd); background:#fff; border-radius:10px;
      padding:6px 10px; font-size:12px; cursor:pointer;
    }
    .clearBtn:hover{ background:#fafafa; }
    .hint{ font-size:12px; color:var(--muted); margin-top:8px; line-height:1.5; }
    .status{ font-size:12px; white-space:pre-wrap; margin-top:10px; display:flex; align-items:center; gap:8px; }
    .status.ok{ color:var(--ok); }
    .status.bad{ color:var(--warn); }
    .spin{
      width:14px; height:14px; border-radius:999px;
      border:2px solid rgba(17,24,39,.2);
      border-top-color:rgba(17,24,39,.65);
      animation:spin .8s linear infinite;
      display:none;
    }
    .status.loading .spin{ display:inline-block; }
    @keyframes spin{ to{ transform:rotate(360deg); } }

    .grid{ display:grid; grid-template-columns:1fr 1fr; gap:12px; }
    @media (max-width:900px){ .grid{ grid-template-columns:1fr; } }

    .list{
      border:1px solid var(--bd); border-radius:14px; overflow:hidden; background:#fff;
      box-shadow:var(--shadow);
    }
    .list .head{
      padding:10px 12px; background:#fafafa; border-bottom:1px solid var(--bd);
      font-weight:700; font-size:13px; display:flex; align-items:center; justify-content:space-between; gap:10px;
    }
    .list .body{ max-height:420px; overflow:auto; scroll-behavior:smooth; }
    .item{
      padding:10px 12px; border-bottom:1px solid var(--bd); font-size:14px;
      display:flex; justify-content:space-between; gap:10px; cursor:pointer;
      transition:background .12s ease;
    }
    .item:hover{ background:#fafafa; }
    .item:last-child{ border-bottom:0; }
    .chip{
      font-size:12px; background:var(--chip); padding:2px 8px; border-radius:999px;
      color:#374151; white-space:nowrap;
    }
    .chip.warn{ background: rgba(254,226,226,.9); color:#7f1d1d; }
    .chip.ok{ background: rgba(220,252,231,.9); color:#065f46; }

    .empty{ color:var(--muted); font-size:13px; padding:12px; }

    table{ width:100%; border-collapse:collapse; }
    th, td{ border-bottom:1px solid var(--bd); padding:10px 10px; text-align:left; font-size:14px; }
    th{ font-size:13px; color:#374151; background:#fafafa; position:sticky; top:0; z-index:1; }

    /* 자동완성 */
    .ac{
      position:absolute; left:0; right:0; top:calc(100% + 8px);
      border:1px solid var(--bd); border-radius:14px; overflow:hidden; background:#fff;
      box-shadow:var(--shadow);
      display:none;
      z-index:10;
    }
    .acHead{
      padding:8px 10px; background:#fafafa; border-bottom:1px solid var(--bd);
      display:flex; justify-content:space-between; align-items:center; gap:10px;
      font-size:12px; color:#374151;
    }
    .acBody{ max-height:260px; overflow:auto; }
    .acRow{
      padding:10px 12px; border-bottom:1px solid var(--bd);
      display:flex; justify-content:space-between; gap:10px;
      cursor:pointer; font-size:14px;
    }
    .acRow:last-child{ border-bottom:0; }
    .acRow:hover, .acRow.active{ background:#f9fafb; }
    mark{
      background:rgba(253,230,138,.55);
      padding:0 2px;
      border-radius:4px;
    }

    /* 담당자 링크/패널 */
    .personLink{ text-decoration:underline; cursor:pointer; color:#1f2937; }
    .personLink:hover{ color:#111827; }
    .panelHead{ display:flex; align-items:center; justify-content:space-between; gap:10px; }
    .panelTitle{ font-weight:800; }
    .panelMeta{ display:flex; gap:8px; flex-wrap:wrap; align-items:center; }
    .miniBtn{
      border:1px solid var(--bd); background:#fff; border-radius:10px;
      padding:6px 10px; font-size:12px; cursor:pointer; text-decoration:none; color:var(--fg);
    }
    .miniBtn:hover{ background:#fafafa; }
    .miniBtn.active{ border-color:#cbd5e1; box-shadow:0 0 0 4px rgba(148,163,184,.18); font-weight:800; }

    /* 날짜 칩 */
    .dateChips{ display:flex; flex-wrap:wrap; gap:6px; margin-top:6px; }
    .dateChip{ font-size:12px; }

    /* 곡 자료(악보/영상) */
    .mediaBox{ border-top:1px solid var(--bd); padding:12px; background:#fff; }
    .mediaRow{ display:flex; gap:10px; align-items:flex-start; flex-wrap:wrap; margin-top:8px; }
    .mediaLabel{ font-size:12px; color:var(--muted); min-width:44px; padding-top:2px; }
    .mediaLinks{ display:flex; gap:6px; flex-wrap:wrap; }
    a.chipLink{ text-decoration:none; }
    .btn{
      border:1px solid var(--bd); background:#fff; border-radius:10px;
      padding:6px 10px; font-size:12px; cursor:pointer;
    }
    .btn:hover{ background:#fafafa; }

    /* 필터 바 */
    .filterRow{
      display:flex; gap:10px; flex-wrap:wrap; align-items:center; justify-content:space-between;
    }
    .filterLeft{
      display:flex; gap:8px; flex-wrap:wrap; align-items:center;
    }
    .filterRight{
      display:flex; gap:8px; flex-wrap:wrap; align-items:center; justify-content:flex-end;
    }
    select{
      border:1px solid var(--bd);
      border-radius:10px;
      padding:6px 10px;
      font-size:12px;
      background:#fff;
      cursor:pointer;
      outline:none;
    }
    select:focus{ border-color:#cbd5e1; box-shadow:0 0 0 4px rgba(148,163,184,.18); }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>쉐키나 찬양팀 곡 검색</h1>
    <div class="sub">
      곡명 검색하면 해당 곡 세션(파트/담당자)이 전부 나옵니다. <b>띄어쓰기 무시</b> / <b>중복 제거</b><br/>
      추천 곡명은 항상 보이고, 오른쪽 결과표는 <b>검색어 입력했을 때만</b> 뜹니다.
    </div>

    <div class="card">
      <label>곡명 검색</label>

      <div class="searchWrap">
        <input id="q" type="text" placeholder="곡명 검색 (예: 꽃들 / 주님 사랑 등)" autocomplete="off" />
        <button id="clear" class="clearBtn" type="button" title="지우기">지우기</button>

        <div id="ac" class="ac" aria-hidden="true">
          <div class="acHead">
            <span>검색 후보</span>
            <span id="acMeta" class="chip">0</span>
          </div>
          <div id="acBody" class="acBody"></div>
        </div>
      </div>

      <div class="hint">
        • 타이핑하면 후보가 뜹니다 (↑↓, Enter 가능) • 추천 곡명 클릭해도 됨
      </div>

      <div id="status" class="status">
        <span class="spin" aria-hidden="true"></span>
        <span id="statusText"></span>
      </div>
    </div>

    <!-- ✅ 곡 목록 필터 -->
    <div class="card" id="filterCard">
      <div class="panelHead">
        <div>
          <div class="panelTitle">곡 목록 필터</div>
          <div class="hint" style="margin:6px 0 0;">
            “최근에 불렀던 곡 흐름도 참고하시고 <b>주일·수련회 콘티도 함께 확인하실 수 있으니 편하게 사용해 주세요</b><br/>
            <b>오늘 하루도 주님 안에서 힘내시길 바랍니다.</b>
          </div>
        </div>
        <span class="chip" id="filterCount">0</span>
      </div>

      <div class="filterRow" style="margin-top:10px;">
        <div class="filterLeft">
          <button class="miniBtn" id="modeRecent" type="button">최근 부른 곡</button>
          <button class="miniBtn" id="modeFrequent" type="button">최근 자주 부른 곡</button>
          <button class="miniBtn" id="modeOld" type="button">오래 안 한 곡</button>

          <span class="chip" id="weeksChip">12주</span>

          <select id="weeksSel" title="기간(주)">
            <option value="4">4주</option>
            <option value="8">8주</option>
            <option value="12" selected>12주</option>
            <option value="24">24주</option>
            <option value="52">52주</option>
          </select>

          <select id="sortSel" title="정렬">
            <option value="default" selected>기본 정렬</option>
            <option value="az">가나다</option>
          </select>

          <button class="miniBtn" id="filterReset" type="button">초기화</button>
        </div>

        <div class="filterRight">
          <span class="chip" id="noDateChip" title="현재 목록 중 날짜가 없는 곡 수">날짜없음 0</span>
        </div>
      </div>
    </div>

    <div class="grid">
      <div class="list">
        <div class="head"><span id="songListTitle">곡 목록</span><span class="chip" id="songCount">0</span></div>
        <div class="body" id="songs"></div>
      </div>

      <div class="list">
        <div class="head">검색 결과 (파트 / 담당자)</div>
        <div class="body">
          <div class="empty" style="padding:10px 12px; border-bottom:1px solid var(--bd); background:#fff;">
            팁: <b>담당자 이름 클릭</b>하면 그 사람이 해본 곡 목록이 뜹니다.
          </div>

          <div id="resultsEmpty" class="empty">검색어를 입력하면 결과가 나와요.</div>

          <table id="resultsTable" style="display:none;">
            <thead>
              <tr><th style="width:40%;">파트</th><th>담당자</th></tr>
            </thead>
            <tbody id="results"></tbody>
          </table>

          <div id="mediaBox" class="mediaBox" style="display:none;">
            <div style="font-weight:800; margin-bottom:2px;">곡 자료</div>
            <div class="hint" style="margin-top:4px;">악보/영상 링크가 있으면 여기 표시됩니다. (중복 링크는 자동 제거)</div>

            <div class="mediaRow" id="scoreRow" style="display:none;">
              <div class="mediaLabel">악보</div>
              <div class="mediaLinks" id="scoreLinks"></div>
            </div>

            <div class="mediaRow" id="videoRow" style="display:none;">
              <div class="mediaLabel">영상</div>
              <div class="mediaLinks" id="videoLinks"></div>
            </div>
          </div>

          <div id="metaBox" style="display:none; border-top:1px solid var(--bd); padding:12px;">
            <div style="display:flex; justify-content:space-between; align-items:flex-start; gap:10px;">
              <div>
                <div style="font-weight:800; margin-bottom:4px;">곡 메모</div>
                <div class="muted" id="metaSong"></div>
              </div>
              <div style="display:flex; gap:8px; flex-wrap:wrap;">
                <a id="metaScoreBtn" class="btn" href="#" target="_blank" rel="noopener" style="display:none; text-decoration:none;">악보</a>
                <a id="metaLinkBtn" class="btn" href="#" target="_blank" rel="noopener" style="display:none; text-decoration:none;">링크</a>
              </div>
            </div>
            <div id="metaNote" class="hint" style="margin-top:10px; white-space:pre-wrap;"></div>
            <div id="metaWarn" class="hint" style="margin-top:8px; white-space:pre-wrap;"></div>
          </div>

        </div>
      </div>
    </div>

    <!-- ===== 콘티 리스트(구글시트 탭) ===== -->
    <div class="card" id="setlistsCard">
      <div class="panelHead">
        <div>
          <div class="panelTitle">콘티 리스트</div>
          <div class="hint" style="margin:6px 0 0;">
            오늘 하루도 화이팅!
          </div>
        </div>
      </div>

      <div class="hint" style="margin-top:10px; font-weight:700;">리스트 선택</div>
      <div id="slTabs" class="dateChips" style="margin-top:8px;"></div>

      <div class="list" style="margin-top:12px;">
        <div class="head">
          <span id="slTitle">-</span>
          <span class="chip" id="slCount">0</span>
        </div>
        <div class="body" id="slBody" style="max-height:360px;"></div>
      </div>

      <div style="display:flex; gap:8px; flex-wrap:wrap; margin-top:12px;">
        <button class="miniBtn" id="slCopyBtn" type="button">복사</button>
        <button class="miniBtn" id="slReloadBtn" type="button">새로고침</button>
      </div>
    </div>

    <div id="personPanel" class="card" style="display:none;">
      <div class="panelHead">
        <div>
          <div class="panelTitle"><span id="ppName"></span> · 참여 기록</div>
          <div class="hint" style="margin:6px 0 0;">아래 곡 클릭하면 검색창에 자동 입력됩니다.</div>
        </div>
        <div class="panelMeta">
          <span class="chip" id="ppSongCount">0곡</span>
          <button class="miniBtn" id="ppClose" type="button">닫기</button>
        </div>
      </div>

      <div class="list" style="margin-top:10px;">
        <div class="head"><span>해본 곡 목록</span><span class="chip" id="ppRowCount">0행</span></div>
        <div class="body" id="ppBody"></div>
      </div>
    </div>

<script>
  // ====== 설정(네 시트) ======
  const FIXED_SHEET_URL = 'https://docs.google.com/spreadsheets/d/1fyGPILf7sxYSBLx1gq7hFeZwV0enO0F3ufh-9DmbJp0/edit?gid=1851883768#gid=1851883768';
  const FIXED_GID = '1851883768';
  const FIXED_SHEET_NAME = 'DB';

  // META 탭(선택)
  const META_SHEET_NAME = 'META';
  const META_GID = ''; // 모르면 비워두면 됨

  // 콘티 탭 3개(반드시 이 이름으로 탭 생성)
  const SETLIST_TABS = [
    { key: "sunday", title: "주일 콘티", sheet: "주일콘티" },
    { key: "winter2026", title: "2026 겨울수련회 콘티", sheet: "2026겨울수련회콘티" },
    { key: "summer2026", title: "2026 여름수련회 콘티", sheet: "2026여름수련회콘티" },
  ];

  // ===== 유틸 =====
  const KST_TZ = "Asia/Seoul";
  const KST_OFFSET_HOURS = 9;

  // 텍스트 정규화: 공백/제로폭/BOM 제거 + 소문자
  function norm(s){
    return (s ?? "").toString().replace(/[\s\u200B\u200C\u200D\uFEFF]+/g, "").toLowerCase();
  }
  const trim = (s) => (s ?? "").toString().trim();

  // ✅ "지금"을 한국시간 기준으로 고정한 epoch(ms)
  function nowKSTTs(){
    const now = new Date();
    const parts = new Intl.DateTimeFormat("en-US", {
      timeZone: KST_TZ,
      year: "numeric", month: "2-digit", day: "2-digit",
      hour: "2-digit", minute: "2-digit", second: "2-digit",
      hour12: false,
    }).formatToParts(now);

    const map = {};
    for (const p of parts) if (p.type !== "literal") map[p.type] = p.value;

    const y = parseInt(map.year, 10);
    const m = parseInt(map.month, 10);
    const d = parseInt(map.day, 10);
    const hh = parseInt(map.hour, 10);
    const mm = parseInt(map.minute, 10);
    const ss = parseInt(map.second, 10);

    // map은 "KST 시각"이므로 UTC epoch로 바꿀 때 9시간 빼줌
    return Date.UTC(y, m - 1, d, hh - KST_OFFSET_HOURS, mm, ss);
  }

  // ✅ epoch(ms)를 한국시간 YYYY-MM-DD로 출력
  function fmtYmdKST(ts){
    if (!ts) return "";
    return new Intl.DateTimeFormat("en-CA", {
      timeZone: KST_TZ,
      year: "numeric",
      month: "2-digit",
      day: "2-digit",
    }).format(new Date(ts));
  }

  function normDateStr(d){
    const s = trim((d ?? "").toString());
    if (!s) return "";

    // GVIZ Date(2026,0,4) 또는 2026,0,4
    let m = s.match(/Date\(\s*(\d{4})\s*,\s*(\d{1,2})\s*,\s*(\d{1,2})/i);
    if (!m) m = s.match(/^(\d{4})\s*,\s*(\d{1,2})\s*,\s*(\d{1,2})/);
    if (m){
      const y = m[1];
      const mm = String(parseInt(m[2],10)+1).padStart(2,"0");
      const dd = String(parseInt(m[3],10)).padStart(2,"0");
      return `${y}-${mm}-${dd}`;
    }

    // YYYY.MM.DD / YYYY/MM/DD -> YYYY-MM-DD
    m = s.match(/^(\d{4})[.\-/](\d{1,2})[.\-/](\d{1,2})/);
    if (m){
      const y = m[1];
      const mm = m[2].padStart(2,"0");
      const dd = m[3].padStart(2,"0");
      return `${y}-${mm}-${dd}`;
    }

    if (/^\d{4}-\d{2}-\d{2}$/.test(s)) return s;
    return s;
  }

  // ✅ DB 날짜(YYYY-MM-DD)는 "한국 달력 날짜"로 해석(해외 접속해도 동일)
  function toDateTs(v){
    const s = normDateStr(v);
    if (!s) return null;
    if (/^\d{4}-\d{2}-\d{2}$/.test(s)){
      const [y, m, d] = s.split("-").map(n => parseInt(n,10));
      // KST 자정(00:00)을 UTC로 환산 = 전날 15:00Z
      const ts = Date.UTC(y, m-1, d, -KST_OFFSET_HOURS, 0, 0);
      return Number.isFinite(ts) ? ts : null;
    }
    return null;
  }

  function escapeHTML(s){
    return (s ?? "").toString()
      .replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;")
      .replaceAll('"',"&quot;").replaceAll("'","&#039;");
  }

  function highlight(text, queryNorm){
    if (!queryNorm) return escapeHTML(text);
    const raw = (text ?? "").toString();
    const rawNoSpace = raw.replace(/[\s\u200B\u200C\u200D\uFEFF]+/g, "");
    const idx = rawNoSpace.toLowerCase().indexOf(queryNorm);
    if (idx < 0) return escapeHTML(raw);

    let start=-1, end=-1, count=0;
    for (let i=0;i<raw.length;i++){
      const ch=raw[i];
      if (/[\s\u200B\u200C\u200D\uFEFF]/.test(ch)) continue;
      if (count===idx) start=i;
      if (count===idx+queryNorm.length-1){ end=i; break; }
      count++;
    }
    if (start<0 || end<0) return escapeHTML(raw);
    return escapeHTML(raw.slice(0,start)) + "<mark>" + escapeHTML(raw.slice(start,end+1)) + "</mark>" + escapeHTML(raw.slice(end+1));
  }

  function uniqueBy(arr, keyFn){
    const seen = new Set();
    const out = [];
    for (const x of arr){
      const k = keyFn(x);
      if (seen.has(k)) continue;
      seen.add(k);
      out.push(x);
    }
    return out;
  }

  function extractSheetId(url){
    const m = url.match(/spreadsheets\/d\/([a-zA-Z0-9-_]+)/);
    return m ? m[1] : null;
  }

  // ✅ 표시도 한국시간 고정
  function fmtYmd(ts){
    return fmtYmdKST(ts);
  }

  // ===== DOM =====
  const elQ = document.getElementById("q");
  const elClear = document.getElementById("clear");
  const elSongs = document.getElementById("songs");
  const elSongCount = document.getElementById("songCount");
  const elSongListTitle = document.getElementById("songListTitle");

  const elResultsEmpty = document.getElementById("resultsEmpty");
  const elResultsTable = document.getElementById("resultsTable");
  const elResults = document.getElementById("results");

  const elMediaBox = document.getElementById("mediaBox");
  const elScoreRow = document.getElementById("scoreRow");
  const elVideoRow = document.getElementById("videoRow");
  const elScoreLinks = document.getElementById("scoreLinks");
  const elVideoLinks = document.getElementById("videoLinks");

  const elMetaBox = document.getElementById("metaBox");
  const elMetaSong = document.getElementById("metaSong");
  const elMetaScoreBtn = document.getElementById("metaScoreBtn");
  const elMetaLinkBtn = document.getElementById("metaLinkBtn");
  const elMetaNote = document.getElementById("metaNote");
  const elMetaWarn = document.getElementById("metaWarn");

  const elStatus = document.getElementById("status");
  const elStatusText = document.getElementById("statusText");

  const elAC = document.getElementById("ac");
  const elACBody = document.getElementById("acBody");
  const elACMeta = document.getElementById("acMeta");

  const elPersonPanel = document.getElementById("personPanel");
  const elPPName = document.getElementById("ppName");
  const elPPSongCount = document.getElementById("ppSongCount");
  const elPPRowCount = document.getElementById("ppRowCount");
  const elPPBody = document.getElementById("ppBody");
  const elPPClose = document.getElementById("ppClose");

  // setlist dom
  const elSlTabs = document.getElementById("slTabs");
  const elSlTitle = document.getElementById("slTitle");
  const elSlCount = document.getElementById("slCount");
  const elSlBody = document.getElementById("slBody");
  const elSlCopyBtn = document.getElementById("slCopyBtn");
  const elSlReloadBtn = document.getElementById("slReloadBtn");

  // filter dom
  const elModeRecent = document.getElementById("modeRecent");
  const elModeFrequent = document.getElementById("modeFrequent");
  const elModeOld = document.getElementById("modeOld");
  const elWeeksSel = document.getElementById("weeksSel");
  const elWeeksChip = document.getElementById("weeksChip");
  const elSortSel = document.getElementById("sortSel");
  const elFilterReset = document.getElementById("filterReset");
  const elFilterCount = document.getElementById("filterCount");
  const elNoDateChip = document.getElementById("noDateChip");

  function setStatus(msg, ok=true, loading=false){
    elStatusText.textContent = msg;
    elStatus.className = "status " + (loading ? "loading" : "") + " " + (ok ? "ok" : "bad");
  }

  // ===== 데이터 =====
  let DB = [];
  let META = new Map(); // songKey -> {song, scoreUrl, linkUrl, note, warn}
  let SONGS = [];       // 전체 곡명 목록 (DB 기반)
  let SONG_INFO = new Map(); // songKey -> { song, lastTs, totalCount, tsList: number[] } (날짜 있는 기록만 tsList에 저장)
  let LAST_MEDIA = { scores: new Set(), videos: new Set() };

  // filter state
  const FILTER_DEFAULT = { mode: "recent", weeks: 12, sort: "default" };
  let FILTER = { ...FILTER_DEFAULT };
  const FREQUENT_MIN_COUNT = 2; // “최근 자주 부른 곡” 기준(2회 이상)

  // setlists
  let activeSetlistKey = SETLIST_TABS[0].key;
  let SETLIST_CACHE = new Map(); // key -> [songs...]

  function rebuildSongs(){
    SONGS = uniqueBy(DB, r => r.songKey).map(r => r.song).sort((a,b) => a.localeCompare(b,"ko"));
  }

  function buildSongInfo(){
    SONG_INFO = new Map();
    for (const r of DB){
      const sk = r.songKey;
      if (!SONG_INFO.has(sk)){
        SONG_INFO.set(sk, { song: r.song, lastTs: null, totalCount: 0, tsList: [] });
      }
      const it = SONG_INFO.get(sk);
      it.song = it.song || r.song;
      it.totalCount += 1;

      const ts = toDateTs(r.date);
      if (ts){
        it.tsList.push(ts);
        if (!it.lastTs || ts > it.lastTs) it.lastTs = ts;
      }
    }
    for (const it of SONG_INFO.values()){
      it.tsList.sort((a,b) => a - b);
    }
  }

  // ✅ cutoff 계산의 '오늘'도 한국시간 고정
  function cutoffTsByWeeks(weeks){
    const nowTs = nowKSTTs();
    const ms = weeks * 7 * 24 * 60 * 60 * 1000;
    return nowTs - ms;
  }

  function countInWindow(tsList, cutoffTs){
    let lo = 0, hi = tsList.length;
    while (lo < hi){
      const mid = (lo + hi) >> 1;
      if (tsList[mid] < cutoffTs) lo = mid + 1;
      else hi = mid;
    }
    return tsList.length - lo;
  }

  // ✅ 날짜 없는 곡도 결과에 포함(클릭 가능)
  function getFilteredSongKeys(){
    const cutoff = cutoffTsByWeeks(FILTER.weeks);

    let keys = [];
    let noDateCount = 0;

    for (const [sk, info] of SONG_INFO.entries()){
      const hasDate = !!info.lastTs;

      if (!hasDate){
        noDateCount += 1;
        keys.push(sk);
        continue;
      }

      if (FILTER.mode === "recent"){
        const c = countInWindow(info.tsList, cutoff);
        if (c >= 1) keys.push(sk);
      } else if (FILTER.mode === "frequent"){
        const c = countInWindow(info.tsList, cutoff);
        if (c >= FREQUENT_MIN_COUNT) keys.push(sk);
      } else if (FILTER.mode === "old"){
        if (info.lastTs < cutoff) keys.push(sk);
      }
    }

    elNoDateChip.textContent = "날짜없음 " + noDateCount;
    elNoDateChip.style.display = noDateCount ? "inline-block" : "none";

    return keys;
  }

  function getFilteredSongs(){
    const keys = getFilteredSongKeys();
    const list = keys.map(sk => {
      const info = SONG_INFO.get(sk);
      return { songKey: sk, song: info?.song || "", info };
    });

    if (FILTER.sort === "az"){
      list.sort((a,b) => a.song.localeCompare(b.song, "ko"));
    } else {
      if (FILTER.mode === "recent"){
        list.sort((a,b) => ((b.info.lastTs || 0) - (a.info.lastTs || 0)));
      } else if (FILTER.mode === "frequent"){
        const cutoff = cutoffTsByWeeks(FILTER.weeks);
        list.sort((a,b) => {
          const ca = countInWindow(a.info.tsList, cutoff);
          const cb = countInWindow(b.info.tsList, cutoff);
          if (cb !== ca) return cb - ca;
          return (b.info.lastTs || 0) - (a.info.lastTs || 0);
        });
      } else if (FILTER.mode === "old"){
        list.sort((a,b) => {
          const ta = (a.info.lastTs === null) ? Number.POSITIVE_INFINITY : a.info.lastTs;
          const tb = (b.info.lastTs === null) ? Number.POSITIVE_INFINITY : b.info.lastTs;
          return ta - tb;
        });
      }
    }

    return list;
  }

  // ===== GVIZ JSONP =====
  function loadGvizJSONP(url){
    return new Promise((resolve, reject) => {
      const cbName = "__gviz_cb_" + Math.random().toString(36).slice(2);
      const timeout = setTimeout(() => {
        cleanup();
        reject(new Error("타임아웃: GVIZ 응답 없음"));
      }, 12000);

      let script = null;
      function cleanup(){
        clearTimeout(timeout);
        try{ delete window[cbName]; }catch(e){}
        if (script && script.parentNode) script.parentNode.removeChild(script);
      }

      window[cbName] = (payload) => {
        try{
          cleanup();
          if (payload && payload.status && payload.status !== "ok"){
            const msg = (payload.errors && payload.errors.length)
              ? payload.errors.map(e => e.message).join(" / ")
              : ("GVIZ status=" + payload.status);
            reject(new Error(msg));
            return;
          }
          const table = payload.table;
          const cols = table.cols.map(c => (c.label || "").trim());
          const rows = table.rows.map(r => r.c.map(c => (c && c.v !== null && c.v !== undefined) ? String(c.v) : ""));
          resolve({ cols, rows });
        }catch(e){
          reject(new Error("파싱 실패: " + e.message));
        }
      };

      window.google = window.google || {};
      window.google.visualization = window.google.visualization || {};
      window.google.visualization.Query = window.google.visualization.Query || {};
      window.google.visualization.Query.setResponse = (payload) => window[cbName](payload);

      script = document.createElement("script");
      script.src = url;
      script.onerror = () => { cleanup(); reject(new Error("스크립트 로드 실패")); };
      document.head.appendChild(script);
    });
  }

  function findCol(headerNorm, candidates){
    for (const c of candidates){
      const i = headerNorm.findIndex(h => h === c);
      if (i >= 0) return i;
    }
    for (const c of candidates){
      const i = headerNorm.findIndex(h => h.includes(c));
      if (i >= 0) return i;
    }
    return -1;
  }

  function toDBWithHeaderRecovery(cols, rows){
    const songKeys = ["곡명","노래","노래제목","제목","song","title","name"];
    const partKeys = ["파트악기","파트","악기","instrument","part","세션"];
    const personKeys = ["담당자","담당","연주자","멤버","이름","person","member"];
    const dateKeys = ["등록일","날짜","일자","date","when","time","일시"];
    const scoreKeys = ["악보url","악보","score","sheet","chord","악보링크"];
    const videoKeys = ["영상url","영상","video","youtube","유튜브"];

    let header = cols.map(h => norm(h));
    let dataRows = rows;

    let idxSong = findCol(header, songKeys);
    let idxPart = findCol(header, partKeys);
    let idxPerson = findCol(header, personKeys);
    let idxDate = findCol(header, dateKeys);
    let idxScore = findCol(header, scoreKeys);
    let idxVideo = findCol(header, videoKeys);

    const labelsBad = header.every(h => !h || /^[a-z]$/.test(h));
    if ((idxSong < 0 || idxPart < 0 || idxPerson < 0) && dataRows.length && labelsBad){
      const firstRowHeader = dataRows[0].map(v => norm(v));
      const s2 = findCol(firstRowHeader, songKeys);
      const p2 = findCol(firstRowHeader, partKeys);
      const m2 = findCol(firstRowHeader, personKeys);
      const d2 = findCol(firstRowHeader, dateKeys);
      const sc2 = findCol(firstRowHeader, scoreKeys);
      const vd2 = findCol(firstRowHeader, videoKeys);
      if (s2 >= 0 && p2 >= 0 && m2 >= 0){
        header = firstRowHeader;
        idxSong = s2; idxPart = p2; idxPerson = m2;
        idxDate = d2; idxScore = sc2; idxVideo = vd2;
        dataRows = dataRows.slice(1);
      }
    }

    if (idxSong < 0 || idxPart < 0 || idxPerson < 0){
      const seenCols = cols.filter(Boolean).slice(0, 12).join(", ") || "(빈 헤더)";
      const seenRow1 = (rows[0] ? rows[0].slice(0, 12).join(", ") : "(첫행 없음)");
      throw new Error("컬럼 매칭 실패\n감지된 헤더(label): " + seenCols + "\n첫 행(미리보기): " + seenRow1);
    }

    const out = [];
    for (const r of dataRows){
      const song = trim(r[idxSong] ?? "");
      const part = trim(r[idxPart] ?? "");
      const person = trim(r[idxPerson] ?? "");
      const date = (idxDate >= 0) ? trim(r[idxDate] ?? "") : "";
      const scoreUrl = (idxScore >= 0) ? trim(r[idxScore] ?? "") : "";
      const videoUrl = (idxVideo >= 0) ? trim(r[idxVideo] ?? "") : "";
      if (!song || !part || !person) continue;

      out.push({
        song, part, person, date, scoreUrl, videoUrl,
        songKey: norm(song),
        partKey: norm(part),
        personKey: norm(person),
      });
    }
    return out;
  }

  function toMetaMapWithHeaderRecovery(cols, rows){
    const songKeys = ["곡명","노래","노래제목","제목","song","title","name"];
    const scoreKeys = ["악보url","악보","score","sheet","chord","악보링크"];
    const noteKeys = ["메모","노트","note","memo","콘티메모","콘티"];
    const warnKeys = ["주의사항","주의","warn","warning","주의점","유의사항"];
    const linkKeys = ["링크","url","영상","youtube","참고","reference"];

    const colLabels = cols.map(h => norm(h));
    let idxSong = findCol(colLabels, songKeys);
    let idxScore = findCol(colLabels, scoreKeys);
    let idxNote = findCol(colLabels, noteKeys);
    let idxWarn = findCol(colLabels, warnKeys);
    let idxLink = findCol(colLabels, linkKeys);

    let startRow = 0;
    if (idxSong < 0 && rows && rows.length){
      const first = rows[0].map(v => norm(v));
      const s2 = findCol(first, songKeys);
      if (s2 >= 0){
        idxSong = s2;
        idxScore = findCol(first, scoreKeys);
        idxNote = findCol(first, noteKeys);
        idxWarn = findCol(first, warnKeys);
        idxLink = findCol(first, linkKeys);
        startRow = 1;
      }
    }

    const m = new Map();
    for (let i=startRow;i<rows.length;i++){
      const r = rows[i];
      const song = trim(r[idxSong]);
      if (!song) continue;
      const key = norm(song);

      const scoreUrl = idxScore >= 0 ? trim(r[idxScore]) : "";
      const linkUrl  = idxLink  >= 0 ? trim(r[idxLink])  : "";
      const note     = idxNote  >= 0 ? trim(r[idxNote])  : "";
      const warn     = idxWarn  >= 0 ? trim(r[idxWarn])  : "";

      const prev = m.get(key) || { song, scoreUrl:"", linkUrl:"", note:"", warn:"" };
      m.set(key, {
        song: prev.song || song,
        scoreUrl: prev.scoreUrl || scoreUrl,
        linkUrl: prev.linkUrl || linkUrl,
        note: prev.note || note,
        warn: prev.warn || warn,
      });
    }
    return m;
  }

  // ===== 미디어(중복 제거) =====
  function hideMediaBox(){
    elMediaBox.style.display = "none";
    elScoreRow.style.display = "none";
    elVideoRow.style.display = "none";
    elScoreLinks.innerHTML = "";
    elVideoLinks.innerHTML = "";
    LAST_MEDIA = { scores: new Set(), videos: new Set() };
  }

  function makeLinkChip(href, label){
    const a = document.createElement("a");
    a.className = "chip chipLink";
    a.href = href;
    a.target = "_blank";
    a.rel = "noopener";
    a.textContent = label;
    return a;
  }

  function renderMediaForExactSong(exactRows){
    if (!exactRows || !exactRows.length){ hideMediaBox(); return; }

    const qn = norm(elQ.value);
    const meta = META.get(qn);

    const scoreSet = new Set();
    const videoSet = new Set();

    exactRows.forEach(r => {
      if (trim(r.scoreUrl)) scoreSet.add(trim(r.scoreUrl));
      if (trim(r.videoUrl)) videoSet.add(trim(r.videoUrl));
    });
    if (meta){
      if (trim(meta.scoreUrl)) scoreSet.add(trim(meta.scoreUrl));
      if (trim(meta.linkUrl))  videoSet.add(trim(meta.linkUrl));
    }

    const scores = [...scoreSet];
    const videos = [...videoSet];
    LAST_MEDIA = { scores: new Set(scores), videos: new Set(videos) };

    if (!scores.length && !videos.length){ hideMediaBox(); return; }

    elMediaBox.style.display = "block";

    if (scores.length){
      elScoreRow.style.display = "flex";
      elScoreLinks.innerHTML = "";
      scores.slice(0, 6).forEach((u,i) => {
        elScoreLinks.appendChild(makeLinkChip(u, scores.length === 1 ? "악보" : `악보 ${i+1}`));
      });
    } else {
      elScoreRow.style.display = "none";
    }

    if (videos.length){
      elVideoRow.style.display = "flex";
      elVideoLinks.innerHTML = "";
      videos.slice(0, 6).forEach((u,i) => {
        elVideoLinks.appendChild(makeLinkChip(u, videos.length === 1 ? "영상" : `영상 ${i+1}`));
      });
    } else {
      elVideoRow.style.display = "none";
    }
  }

  // ===== META(중복 버튼 숨김) =====
  function hideMetaBox(){
    elMetaBox.style.display = "none";
    elMetaSong.textContent = "";
    elMetaScoreBtn.style.display = "none";
    elMetaLinkBtn.style.display = "none";
    elMetaNote.textContent = "";
    elMetaWarn.textContent = "";
  }

  function renderMetaForSong(){
    const qn = norm(elQ.value);
    if (!qn){ hideMetaBox(); return; }

    const meta = META.get(qn);
    if (!meta){ hideMetaBox(); return; }

    elMetaBox.style.display = "block";
    elMetaSong.textContent = meta.song || elQ.value;

    const sUrl = trim(meta.scoreUrl);
    const lUrl = trim(meta.linkUrl);

    if (sUrl && !LAST_MEDIA.scores.has(sUrl)){
      elMetaScoreBtn.href = sUrl;
      elMetaScoreBtn.style.display = "inline-block";
    } else {
      elMetaScoreBtn.style.display = "none";
    }
    if (lUrl && !LAST_MEDIA.videos.has(lUrl)){
      elMetaLinkBtn.href = lUrl;
      elMetaLinkBtn.style.display = "inline-block";
    } else {
      elMetaLinkBtn.style.display = "none";
    }

    elMetaNote.textContent = meta.note ? ("메모\n" + meta.note) : "";
    elMetaWarn.textContent = meta.warn ? ("주의사항\n" + meta.warn) : "";
  }

  // ===== 오른쪽 결과 =====
  function renderResults(){
    const qn = norm(elQ.value);

    if (!qn){
      elResultsTable.style.display = "none";
      elResultsEmpty.style.display = "block";
      elResultsEmpty.textContent = "검색어를 입력하면 결과가 나와요.";
      elResults.innerHTML = "";
      hideMediaBox();
      hideMetaBox();
      return;
    }

    const matches = DB.filter(r => r.songKey.includes(qn));
    const exact = matches.filter(r => r.songKey === qn);
    const picked = exact.length ? exact : matches;

    if (exact.length) renderMediaForExactSong(exact);
    else hideMediaBox();

    const group = new Map();
    for (const r of picked){
      const k = `${r.partKey}||${r.personKey}`;
      if (!group.has(k)) group.set(k, { part:r.part, person:r.person, dates:new Set() });
      const it = group.get(k);
      const nd = normDateStr(r.date);
      if (nd) it.dates.add(nd);
    }

    const rows = [...group.values()].sort((a,b) => a.part.localeCompare(b.part,"ko"));

    elResults.innerHTML = "";
    if (!rows.length){
      elResultsTable.style.display = "none";
      elResultsEmpty.style.display = "block";
      elResultsEmpty.textContent = "결과 없음";
      hideMetaBox();
      return;
    }

    elResultsEmpty.style.display = "none";
    elResultsTable.style.display = "table";

    rows.forEach(r => {
      const tr = document.createElement("tr");

      const td1 = document.createElement("td");
      td1.textContent = r.part;

      const td2 = document.createElement("td");
      const name = document.createElement("span");
      name.className = "personLink";
      name.textContent = r.person;
      name.title = "클릭하면 이 담당자 참여곡 보기";
      name.addEventListener("click", () => openPersonPanel(r.person));
      td2.appendChild(name);

      const dates = [...r.dates];
      if (dates.length){
        dates.sort((a,b) => b.localeCompare(a));
        const wrap = document.createElement("div");
        wrap.className = "dateChips";
        dates.forEach(d => {
          const chip = document.createElement("span");
          chip.className = "chip dateChip";
          chip.textContent = d;
          wrap.appendChild(chip);
        });
        td2.appendChild(wrap);
      }

      tr.appendChild(td1);
      tr.appendChild(td2);
      elResults.appendChild(tr);
    });

    renderMetaForSong();
  }

  // ===== 왼쪽 곡 목록(필터 적용) =====
  function activeModeLabel(){
    if (FILTER.mode === "recent") return "최근 부른 곡";
    if (FILTER.mode === "frequent") return "최근 자주 부른 곡";
    if (FILTER.mode === "old") return "오래 안 한 곡";
    return "곡 목록";
  }

  function setActiveModeButtons(){
    elModeRecent.classList.toggle("active", FILTER.mode === "recent");
    elModeFrequent.classList.toggle("active", FILTER.mode === "frequent");
    elModeOld.classList.toggle("active", FILTER.mode === "old");
  }

  function renderSongList(){
    const filtered = getFilteredSongs();
    const qn = norm(elQ.value);
    const view = qn ? filtered.filter(x => norm(x.song).includes(qn)) : filtered;

    elWeeksChip.textContent = FILTER.weeks + "주";
    elSongListTitle.textContent = "곡 목록 · " + activeModeLabel() + " (" + FILTER.weeks + "주)";
    elFilterCount.textContent = filtered.length + "곡";
    elSongCount.textContent = view.length.toString();

    elSongs.innerHTML = view.length ? "" : `<div class="empty">조건에 맞는 곡이 없어요.</div>`;

    const cutoff = cutoffTsByWeeks(FILTER.weeks);

    view.slice(0, 600).forEach(x => {
      const div = document.createElement("div");
      div.className = "item";

      let rightChip = "클릭";
      let rightChipClass = "chip";

      if (!x.info || x.info.lastTs === null){
        rightChip = "날짜 없음";
        rightChipClass = "chip warn";
      } else {
        if (FILTER.mode === "recent"){
          rightChip = "마지막 " + fmtYmd(x.info.lastTs);
          rightChipClass = "chip ok";
        } else if (FILTER.mode === "frequent"){
          const c = countInWindow(x.info.tsList, cutoff);
          rightChip = FILTER.weeks + "주 " + c + "회";
          rightChipClass = "chip ok";
        } else if (FILTER.mode === "old"){
          rightChip = "마지막 " + fmtYmd(x.info.lastTs);
          rightChipClass = "chip warn";
        }
      }

      div.innerHTML = `<span>${highlight(x.song, qn)}</span><span class="${rightChipClass}">${escapeHTML(rightChip)}</span>`;
      div.addEventListener("click", () => {
        elQ.value = x.song;
        closeAC();
        renderAll();
        elQ.focus();
      });
      elSongs.appendChild(div);
    });

    if (view.length > 600){
      const more = document.createElement("div");
      more.className = "empty";
      more.textContent = "목록이 많아서 600개까지만 보여줘요. 검색어를 더 입력해 주세요.";
      elSongs.appendChild(more);
    }
  }

  // ===== 자동완성 =====
  let acItems = [];
  let acIndex = -1;

  function openAC(){
    if (!acItems.length) return closeAC();
    elAC.style.display = "block";
    elAC.setAttribute("aria-hidden","false");
  }
  function closeAC(){
    elAC.style.display = "none";
    elAC.setAttribute("aria-hidden","true");
    acIndex = -1;
  }
  function scrollACIntoView(){
    const rows = elACBody.querySelectorAll(".acRow");
    const row = rows[acIndex];
    if (!row) return;
    const top = row.offsetTop;
    const bottom = top + row.offsetHeight;
    if (top < elACBody.scrollTop) elACBody.scrollTop = top;
    else if (bottom > elACBody.scrollTop + elACBody.clientHeight) elACBody.scrollTop = bottom - elACBody.clientHeight;
  }
  function chooseAC(i){
    const item = acItems[i];
    if (!item) return;
    elQ.value = item;
    closeAC();
    renderAll();
    elQ.focus();
  }
  function renderAC(){
    const qn = norm(elQ.value);
    if (!qn){
      closeAC();
      elACBody.innerHTML = "";
      elACMeta.textContent = "0";
      return;
    }
    acItems = SONGS.filter(s => norm(s).includes(qn)).slice(0, 10);
    elACMeta.textContent = String(acItems.length);
    if (!acItems.length) return closeAC();

    openAC();
    elACBody.innerHTML = "";
    acItems.forEach((song, idx) => {
      const row = document.createElement("div");
      row.className = "acRow" + (idx === acIndex ? " active" : "");
      row.innerHTML = `<span>${highlight(song, qn)}</span><span class="chip">Enter</span>`;
      row.addEventListener("mousedown", (e) => {
        e.preventDefault();
        chooseAC(idx);
      });
      elACBody.appendChild(row);
    });
  }
  function stepAC(dir){
    if (elAC.style.display !== "block") return;
    if (!acItems.length) return;
    acIndex = acIndex + dir;
    if (acIndex < 0) acIndex = acItems.length - 1;
    if (acIndex >= acItems.length) acIndex = 0;

    const rows = elACBody.querySelectorAll(".acRow");
    rows.forEach((r,i) => r.classList.toggle("active", i === acIndex));
    scrollACIntoView();
  }

  // ===== 담당자 패널 =====
  function openPersonPanel(personName){
    const pk = norm(personName);
    if (!pk) return;

    const rows = DB.filter(r => r.personKey === pk);

    const songMap = new Map();
    for (const r of rows){
      const sk = r.songKey;
      if (!songMap.has(sk)) songMap.set(sk, { song:r.song, parts:new Set() });
      songMap.get(sk).parts.add(r.part);
    }

    const songs = [...songMap.values()].sort((a,b) => a.song.localeCompare(b.song,"ko"));

    elPPName.textContent = personName;
    elPPSongCount.textContent = songs.length + "곡";
    elPPRowCount.textContent = rows.length + "행";

    elPPBody.innerHTML = "";
    if (!songs.length){
      elPPBody.innerHTML = `<div class="empty">기록 없음</div>`;
    } else {
      songs.forEach(s => {
        const div = document.createElement("div");
        div.className = "item";
        const parts = [...s.parts].join(", ");
        div.innerHTML = `<span>${escapeHTML(s.song)}</span><span class="chip">${escapeHTML(parts || "보기")}</span>`;
        div.addEventListener("click", () => {
          elQ.value = s.song;
          closeAC();
          renderAll();
          window.scrollTo({ top: 0, behavior: "smooth" });
        });
        elPPBody.appendChild(div);
      });
    }

    elPersonPanel.style.display = "block";
  }
  function closePersonPanel(){
    elPersonPanel.style.display = "none";
    elPPBody.innerHTML = "";
  }

  // ===== 콘티(구글시트 탭에서 읽기) =====
  function uniqSongs(arr){
    const seen = new Set();
    const out = [];
    for (const s of arr){
      const t = trim(s);
      if (!t) continue;
      const k = norm(t);
      if (seen.has(k)) continue;
      seen.add(k);
      out.push(t);
    }
    return out;
  }

  async function loadSetlistFromSheet(sheetName){
    const sheetId = extractSheetId(FIXED_SHEET_URL);
    const base = "https://docs.google.com/spreadsheets/d/" + sheetId + "/gviz/tq?tqx=out:json";
    const tq = encodeURIComponent("select A where A is not null");
    const url = base + "&sheet=" + encodeURIComponent(sheetName) + "&tq=" + tq;

    const p = await loadGvizJSONP(url);
    const songs = (p.rows || []).map(r => trim(r[0] ?? "")).filter(Boolean);

    const cleaned = (songs[0] && norm(songs[0]) === norm("곡명")) ? songs.slice(1) : songs;
    return uniqSongs(cleaned);
  }

  async function loadAllSetlists(){
    for (const def of SETLIST_TABS){
      try{
        const songs = await loadSetlistFromSheet(def.sheet);
        SETLIST_CACHE.set(def.key, songs);
      } catch(e){
        SETLIST_CACHE.set(def.key, []);
      }
    }
  }

  function slRenderTabs(){
    elSlTabs.innerHTML = "";
    SETLIST_TABS.forEach(def => {
      const b = document.createElement("button");
      b.type = "button";
      b.className = "miniBtn";
      b.textContent = def.title;
      b.style.borderRadius = "999px";
      if (def.key === activeSetlistKey) b.classList.add("active");
      b.addEventListener("click", () => {
        activeSetlistKey = def.key;
        slRenderTabs();
        slRenderList();
      });
      elSlTabs.appendChild(b);
    });
  }

  function slRenderList(){
    const def = SETLIST_TABS.find(d => d.key === activeSetlistKey);
    const arr = SETLIST_CACHE.get(activeSetlistKey) || [];

    elSlTitle.textContent = def ? def.title : activeSetlistKey;
    elSlCount.textContent = String(arr.length);

    elSlBody.innerHTML = "";
    if (!arr.length){
      elSlBody.innerHTML = `<div class="empty">아직 곡이 없어요. (시트 탭 <b>${escapeHTML(def?.sheet || "")}</b>의 A열에 곡명을 추가해 주세요.)</div>`;
      return;
    }

    arr.forEach((song, idx) => {
      const row = document.createElement("div");
      row.className = "item";
      row.innerHTML = `<span><b style="margin-right:8px;">${idx+1}.</b>${escapeHTML(song)}</span><span class="chip">검색</span>`;
      row.addEventListener("click", () => {
        elQ.value = song;
        closeAC();
        renderAll();
        window.scrollTo({ top: 0, behavior: "smooth" });
      });
      elSlBody.appendChild(row);
    });
  }

  elSlCopyBtn.addEventListener("click", async () => {
    const def = SETLIST_TABS.find(d => d.key === activeSetlistKey);
    const a = SETLIST_CACHE.get(activeSetlistKey) || [];
    const text = [(def ? def.title : activeSetlistKey), ...a.map((s,i) => `${i+1}. ${s}`)].join("\n");

    try{
      await navigator.clipboard.writeText(text);
      setStatus("콘티를 클립보드에 복사했어요.", true, false);
    } catch(e){
      prompt("복사(Ctrl+C) 후 닫기", text);
    }
  });

  elSlReloadBtn.addEventListener("click", async () => {
    setStatus("콘티 불러오는 중…", true, true);
    await loadAllSetlists();
    slRenderTabs();
    slRenderList();
    setStatus("콘티 새로고침 완료", true, false);
  });

  // ===== 필터 이벤트 =====
  function applyFilterAndRender(){
    setActiveModeButtons();
    renderSongList();
    renderAC();
  }

  function setFilterMode(mode){
    FILTER.mode = mode;
    elSortSel.value = "default";
    FILTER.sort = "default";
    applyFilterAndRender();
  }

  elModeRecent.addEventListener("click", () => setFilterMode("recent"));
  elModeFrequent.addEventListener("click", () => setFilterMode("frequent"));
  elModeOld.addEventListener("click", () => setFilterMode("old"));

  elWeeksSel.addEventListener("change", () => {
    FILTER.weeks = parseInt(elWeeksSel.value, 10) || FILTER_DEFAULT.weeks;
    applyFilterAndRender();
  });

  elSortSel.addEventListener("change", () => {
    FILTER.sort = elSortSel.value || "default";
    applyFilterAndRender();
  });

  elFilterReset.addEventListener("click", () => {
    FILTER = { ...FILTER_DEFAULT };
    elWeeksSel.value = String(FILTER.weeks);
    elSortSel.value = "default";
    setFilterMode(FILTER.mode);
  });

  // ===== 전체 렌더 =====
  function renderAll(){
    renderSongList();
    renderResults();
    renderAC();
    slRenderTabs();
    slRenderList();
    setActiveModeButtons();
  }

  // ===== 연결(DB/META/SETLIST) =====
  async function connect(){
    const sheetId = extractSheetId(FIXED_SHEET_URL);
    if (!sheetId){
      setStatus("시트 ID를 못 찾음(링크 형식 확인)", false, false);
      return;
    }

    const base = "https://docs.google.com/spreadsheets/d/" + sheetId + "/gviz/tq?tqx=out:json";
    const urlBySheet = base + "&sheet=" + encodeURIComponent(FIXED_SHEET_NAME);
    const urlByGid = base + "&gid=" + encodeURIComponent(FIXED_GID);

    setStatus("데이터 불러오는 중…", true, true);

    try{
      try{
        const p1 = await loadGvizJSONP(urlBySheet);
        DB = toDBWithHeaderRecovery(p1.cols, p1.rows);
      } catch(e1){
        const p2 = await loadGvizJSONP(urlByGid);
        DB = toDBWithHeaderRecovery(p2.cols, p2.rows);
      }

      rebuildSongs();
      buildSongInfo();

      try{
        const metaUrlBySheet = base + "&sheet=" + encodeURIComponent(META_SHEET_NAME);
        const mp1 = await loadGvizJSONP(metaUrlBySheet);
        META = toMetaMapWithHeaderRecovery(mp1.cols, mp1.rows);
      } catch(e1){
        if (META_GID){
          try{
            const metaUrlByGid = base + "&gid=" + encodeURIComponent(META_GID);
            const mp2 = await loadGvizJSONP(metaUrlByGid);
            META = toMetaMapWithHeaderRecovery(mp2.cols, mp2.rows);
          } catch(e2){
            META = new Map();
          }
        } else {
          META = new Map();
        }
      }

      await loadAllSetlists();

      elWeeksSel.value = String(FILTER.weeks);
      setFilterMode(FILTER.mode);

      renderAll();
      setStatus("연결 완료 (DB " + DB.length + "행 / 곡 " + SONGS.length + "개)", true, false);
    } catch(e){
      setStatus("연결 실패\n" + e.message + "\n\n※ 시트가 '웹에 게시' 또는 '링크 있는 사람 보기'가 아니면 읽을 수 없어요.", false, false);
    }
  }

  // ===== 검색 이벤트 =====
  elQ.addEventListener("input", () => {
    renderAll();
  });

  elQ.addEventListener("keydown", (e) => {
    if (e.key === "ArrowDown"){
      e.preventDefault();
      if (elAC.style.display !== "block") renderAC();
      stepAC(+1);
    } else if (e.key === "ArrowUp"){
      e.preventDefault();
      if (elAC.style.display !== "block") renderAC();
      stepAC(-1);
    } else if (e.key === "Enter"){
      if (elAC.style.display === "block" && acIndex >= 0){
        e.preventDefault();
        chooseAC(acIndex);
      }
    } else if (e.key === "Escape"){
      closeAC();
    }
  });

  elQ.addEventListener("focus", () => renderAC());

  document.addEventListener("click", (e) => {
    if (!elAC.contains(e.target) && e.target !== elQ) closeAC();
  });

  elPPClose.addEventListener("click", closePersonPanel);

  elClear.addEventListener("click", () => {
    elQ.value = "";
    closeAC();
    closePersonPanel();
    hideMediaBox();
    hideMetaBox();
    renderAll();
    elQ.focus();
  });

  // ===== 시작 =====
  setActiveModeButtons();
  slRenderTabs();
  slRenderList();

  setStatus("데이터 불러오는 중…", true, true);
  connect();
  renderAll();
  hideMediaBox();
  hideMetaBox();
</script>
</body>
</html>
